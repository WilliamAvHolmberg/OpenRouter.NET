using System.Collections.Concurrent;
using System.Text;
using System.Text.Json;
using Json.Schema;
using OpenRouter.NET.Models;
using OpenRouter.NET.Tools;

namespace OpenRouter.NET.Internal;

/// <summary>
/// Handles schema-based object generation using LLM structured output
/// </summary>
internal class ObjectGenerator
{
    private readonly Func<ChatCompletionRequest, CancellationToken, Task<ChatCompletionResponse>> _createCompletionAsync;
    private readonly JsonSerializerOptions _jsonOptions;
    private readonly Action<string>? _logCallback;
    private static readonly ConcurrentDictionary<Type, JsonElement> _schemaCache = new ConcurrentDictionary<Type, JsonElement>();

    public ObjectGenerator(
        Func<ChatCompletionRequest, CancellationToken, Task<ChatCompletionResponse>> createCompletionAsync,
        JsonSerializerOptions jsonOptions,
        Action<string>? logCallback = null)
    {
        _createCompletionAsync = createCompletionAsync ?? throw new ArgumentNullException(nameof(createCompletionAsync));
        _jsonOptions = jsonOptions ?? throw new ArgumentNullException(nameof(jsonOptions));
        _logCallback = logCallback;
    }

    /// <summary>
    /// Generates an object matching the provided JSON schema
    /// </summary>
    public async Task<GenerateObjectResult> GenerateObjectAsync(
        JsonElement schema,
        string prompt,
        string model,
        GenerateObjectOptions? options = null,
        CancellationToken cancellationToken = default)
    {
        if (string.IsNullOrWhiteSpace(prompt))
            throw new ArgumentException("Prompt cannot be empty", nameof(prompt));

        if (string.IsNullOrWhiteSpace(model))
            throw new ArgumentException("Model cannot be empty", nameof(model));

        options ??= new GenerateObjectOptions();

        var schemaJson = schema.GetRawText();
        var schemaSizeBytes = Encoding.UTF8.GetByteCount(schemaJson);

        if (schemaSizeBytes > options.SchemaWarningThresholdBytes)
        {
            Log($"WARNING: Schema size ({schemaSizeBytes} bytes) exceeds threshold ({options.SchemaWarningThresholdBytes} bytes). This may impact performance.");
        }

        var toolName = "generate_structured_output";
        var tool = Tool.CreateFunctionTool(
            name: toolName,
            description: "Generate structured output matching the provided schema",
            parameters: schema
        );

        Exception? lastException = null;

        for (int attempt = 0; attempt < options.MaxRetries; attempt++)
        {
            try
            {
                var request = new ChatCompletionRequest
                {
                    Model = model,
                    Messages = new List<Message>
                    {
                        Message.FromSystem("You are a helpful assistant that generates structured data exactly matching the provided schema. Follow the schema strictly and include all required fields."),
                        Message.FromUser(prompt)
                    },
                    Tools = new List<Tool> { tool },
                    ToolChoice = new { type = "function", function = new { name = toolName } },
                    Temperature = (float?)(options.Temperature ?? 0.7),
                    MaxTokens = options.MaxTokens
                };

                Log($"GenerateObject attempt {attempt + 1}/{options.MaxRetries}");

                var response = await _createCompletionAsync(request, cancellationToken);

                var choice = response.Choices?.FirstOrDefault();
                var toolCall = choice?.Message?.ToolCalls?.FirstOrDefault();

                if (toolCall?.Function?.Arguments == null)
                {
                    throw new OpenRouterException("No structured output generated by the model");
                }

                var generatedObject = JsonSerializer.Deserialize<JsonElement>(toolCall.Function.Arguments);

                ValidateJsonAgainstSchema(schema, generatedObject);

                Log($"Successfully generated structured object on attempt {attempt + 1}");

                return new GenerateObjectResult
                {
                    Object = generatedObject,
                    Usage = response.Usage,
                    FinishReason = choice?.FinishReason
                };
            }
            catch (Exception ex) when (attempt < options.MaxRetries - 1)
            {
                lastException = ex;
                var delayMs = (int)Math.Pow(2, attempt) * 1000;
                Log($"GenerateObject attempt {attempt + 1} failed: {ex.Message}. Retrying in {delayMs}ms...");
                await Task.Delay(delayMs, cancellationToken);
            }
        }

        throw new OpenRouterException(
            $"Failed to generate structured object after {options.MaxRetries} attempts. Last error: {lastException?.Message}",
            lastException!);
    }

    /// <summary>
    /// Generates a strongly-typed object matching the provided C# type
    /// </summary>
    public async Task<GenerateObjectResult<T>> GenerateObjectAsync<T>(
        string prompt,
        string model,
        GenerateObjectOptions? options = null,
        CancellationToken cancellationToken = default) where T : class
    {
        // Get or generate schema from type
        var schema = _schemaCache.GetOrAdd(typeof(T), type =>
        {
            var schemaObj = SchemaGenerator.GenerateSchema(type);
            var schemaJson = JsonSerializer.Serialize(schemaObj, _jsonOptions);
            return JsonSerializer.Deserialize<JsonElement>(schemaJson);
        });

        // Call the existing untyped method
        var result = await GenerateObjectAsync(schema, prompt, model, options, cancellationToken);

        // Deserialize to typed object
        var typedObject = JsonSerializer.Deserialize<T>(result.Object.GetRawText(), _jsonOptions);

        if (typedObject == null)
        {
            throw new OpenRouterException("Failed to deserialize generated object to target type");
        }

        return new GenerateObjectResult<T>
        {
            Object = typedObject,
            Usage = result.Usage,
            FinishReason = result.FinishReason
        };
    }

    /// <summary>
    /// Validates a JSON element against a JSON schema
    /// </summary>
    internal void ValidateJsonAgainstSchema(JsonElement schema, JsonElement generatedObject)
    {
        var schemaObj = JsonSerializer.Deserialize<JsonSchema>(schema.GetRawText());
        if (schemaObj == null)
        {
            throw new OpenRouterException("Invalid schema provided for validation");
        }

        var results = schemaObj.Evaluate(generatedObject, new EvaluationOptions
        {
            OutputFormat = OutputFormat.Hierarchical
        });

        if (!results.IsValid)
        {
            var errors = new StringBuilder();
            errors.AppendLine("Generated object does not match schema:");

            CollectValidationErrors(results, errors, "");

            throw new OpenRouterException(errors.ToString().TrimEnd());
        }
    }

    /// <summary>
    /// Recursively collects validation errors from evaluation results
    /// </summary>
    internal void CollectValidationErrors(EvaluationResults results, StringBuilder errors, string path)
    {
        if (results.Errors != null)
        {
            foreach (var (key, value) in results.Errors)
            {
                errors.AppendLine($"  - {path}{key}: {value}");
            }
        }

        if (results.Details != null)
        {
            foreach (var detail in results.Details)
            {
                var newPath = string.IsNullOrEmpty(path)
                    ? detail.InstanceLocation.ToString()
                    : $"{path}/{detail.InstanceLocation}";
                CollectValidationErrors(detail, errors, newPath);
            }
        }
    }

    private void Log(string message)
    {
        _logCallback?.Invoke(message);
    }
}
